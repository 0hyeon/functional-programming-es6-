//참조투명성 : 그것을 평가한 값으로 대체해도 프로그램의 동작변화하지 않는다.

//tenDivideBy 함수는 입력값 n에 대해 10을 n으로 나눈 결과를 반환합니다
//그러나 n이 0일 때, 예외를 발생시킵니다.
//이것은 함수의 참조 투명성을 깨는 것입니다. 왜냐하면 0으로 나누는 경우와 그렇지 않은 경우에 대해 동일한 입력에 대해 항상 동일한 결과를 반환하지 않기 때문입니다.
const tenDivideBy = (n: number): number => {
  //실습을위한 10을 n으로 나누는 함수
  if (n === 0) {
    throw new Error("0으로 나눌 수 없습니다 .");
  }
  return 10 / n;
};

const test2 = (n: number): number => {
  //TODO:이렇게해도되지 않나요
  // test2 함수는 tenDivideBy를 호출하고 0으로 나누는 경우 예외가 발생하면 1을 반환하는 형태로 예외 처리를 시도하는 것으로 보입니다. 그러나 이렇게 예외를 처리하는 방식은 참조 투명성을 회복하지 않습니다. 여전히 예외가 발생하는 경우에는 예외가 발생하고, 그로 인해 함수의 반환 값이 달라집니다.
  try {
    return tenDivideBy(0);
  } catch (e) {
    return 1;
  }
};
// 참조 투명성을 유지하려면 예외를 발생시키는 대신, 예외가 발생하는 상황을 명시적으로 처리하고 일반적인 값을 반환해야 합니다. tenDivideBy 함수의 경우, 0으로 나누는 경우에 대한 예외 처리를 제거하고 대신 결과 값을 0으로 나눌 수 없는 상황에서 어떤 값으로 대체할지를 결정해야 합니다.

// 그러면 tenDivideBy 함수는 참조 투명하게 되고, 예외 처리가 필요한 경우 try-catch를 사용하는 것이 아니라 함수의 반환 값을 검사하여 예외 상황을 처리할 수 있게 됩니다.

// 리턴타입만으로는 예외를 발생하는 함수인지 아닌지 알수없다.
// 타입만으로 예외를 발생하는지 알수가 없어 별도의 예외를 분석하는 방법밖에없다
// 이렇게 throw Error를 던지는 대신 명시적인 값으로 돌려주는 방법이 있다.
// try catch는 아직 참조가 투명하지않다.

const test = () => {
  // const y = tenDivideBy(0);
  // => 예외가 발생하는 코드는 try블럭 바깥에 있으면 알수없다. =>참조가 투명한지 아닌지 모른다.
  // TODO:에러를 명시적인 값으로 리턴하는 방법에 대해서 다음시간에 알아보자
  try {
    const y = tenDivideBy(0);
    return y;
  } catch (e) {
    return 1;
  }
};

const main = () => {
  const x = test();
  console.log(x);
  console.log("프로그램이 종료되었습니다.");
};
